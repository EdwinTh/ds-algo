---
title: "Chapter2 - exercises"
format: html
jupyter: python3
---

# R-2.4

```{python}
class Flower:
    def __init__(self, name, nr_petals, price):
        self._name = name
        self._nr_petals = nr_petals
        self._price = price
    
    def change_name(self, name):
        self._name = name
    
    def get_name(self):
        return self._name
```

# R-2.5

```{python}
def charge(price):
    if not isinstance(price, (float, int)):
        raise ValueError("price is of unvalid data type")

```

# R-2.7

We can just add parameter `balance` with default value 0.

# R-2.11

```{python}
class Vector:
    def __init__(self, init_val):
        if not isinstance(init_val, (int, list)):
            raise ValueError("init_val should be a list or an int")
        if isinstance(init_val, int):
            self._coords = [0] * init_val
        else:
            if not all([isinstance(el, (int, float)) for el in coords]):
                raise ValueError("All ellements in coords should be numeric")
            self._coords = int_val

    def __len__(self):
        return len(self._coords)

    def __getitem__(self, j):
        return self._coords[j]

    def __radd__(self, other):
        result = []
        for i in range(len(self)):
            result.append(self[i] + other[i])
        return Vector(result)
    
    def __mul__(self, val):
        if not isinstance(val, (list, Vector, int, float)):
            raise ValueError("Vector multiplication only works with list/Vector or a numeric value")
        if isinstance(val, (int, float)):
            return Vector([el * val for el in self._coords])
        return sum([a * b for a,b in zip(self._coords, val)])
```

# R-2.19
128^x = 2^(x*7) So 128^9 = 2^63, since 63 / 7 = 9

# C-2.27

```{python}
class Range:
    def __init__(self, start, stop=None, step=1):
        if stop is None:
            start, stop = 0, start

        self._length = max(0, (stop - start + step -1) // step)
        self._start = start
        self._step = step

    def __len__(self):
        return self._length
    
    def __getitem__(self, k):
        if k < 0:
            k += len(self)
        if not 0 <= k < self._length:
            raise IndexError('index out of range')
        return self._start + k * self._step

    def __contains__(self, v):
        if v > self._length or v < self._start:
            return False
        return (v - self._start) % self._step == 0 
```

# C-2.28
```{python}
from src2.credit_card import CreditCard
class PredatoryCreditCard2(CreditCard):
  
  def __init__(self, customer, bank, acnt, limit, apr):
    super().__init__(customer, bank, acnt, limit)  # call super constructor
    self._apr = apr
    self._charge_cnt = 0

  def charge(self, price):
    success = super().charge(price)          # call inherited method
    if not success:
      self._balance += 5                     # assess penalty
    self._charge_cnt += 1
    return success                           # caller expects return value

  def process_month(self):
    """Assess monthly interest on outstanding balance."""
    if self._balance > 0:
      # if positive balance, convert APR to monthly multiplicative factor
      monthly_factor = pow(1 + self._apr, 1/12)
      self._balance *= monthly_factor
      self._balance = max(0, self._charge_cnt - 10)
      self._charge_cnt = 0
```

# C-2.31

```{python}
from src2.progressions import Progression
class AbsDifProgression(Progression):
    def __init__(self, first = 2, second = 200):
        self._current = second
        self._prev = first

    def _advance(self):
        self._prev, self._current = self._curent, abs(self._current - self._prev)
```
